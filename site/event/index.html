<?php 
$title="Yahoo! UI Library: Event Utility";
$section="event";
$component="YUI Event Utility";
$highlightSyntax = true;
$releasenotes = true;
include "../inc/header.inc";
?>

<div id="yui-main">
<div class="yui-b">
  <div class="yui-ge">
      <div class="yui-u first">
	  
  <div id="promo" class="component">
    <h1>Yahoo! UI Library: Event Utility</h1>
    <p>
  The YUI Event Utility facilitates the creation of event-driven applications in
  the browser by giving you a simplified interface for subscribing to DOM
  events and for examining properties of the browser's Event object. The Event Utility package includes the Custom Event object; Custom Events allow you to
  &quot;publish&quot; the interesting moments or events in your own code
  so that other components on the page can &quot;subscribe&quot; to those events
  and respond to them. The Event Utility package provides the following features: </p>

    <ul>
      <li> A flexible method of attaching an event handler to one or more elements</li>
      <li> Automatic deferral of handler attachment for elements that are not yet available</li>
      <li> Automatic scope correction, optional scope assignment</li>
      <li> Automatic event object browser abstraction</li>
      <li> The ability to include an arbitrary object to be sent to the handler
        with the event</li>
      <li> Utility methods to access event properties that require browser abstraction</li>
      <li> Automatic listener cleanup</li>
      <li> A mechanism for creating and subscribing to custom events</li>
      <li> The ability to execute functions as soon as a DOM element is detected</li>
   </ul>
    
    <div>
    <h4>On This Page:</h4>
    <ul>
      <li><a href="#start">Getting Started</a></li>
      <li><a href="#event">Using the Event Utility</a> </li>
      <li><a href="#onavailable">Using the <code>onAvailable</code> and <code>onContentReady</code> Methods</a></li>
      <li><a href="#ondomready">Using the <code>onDOMReady</code> Method</a></li>
      <li><a href="#customevent">Using the CustomEvent Object </a></li>
      <li><a href="#support">Support &amp; Community</a></li><li><a href="#filingbugs">Filing Bugs and Feature Requests</a></li>
    </ul>
  </div>

<?php
include('../inc/quicklinks.inc');
?>
    
  </div>

  <h2 class="first">Getting Started<a name="start"></a></h2>
  <p>To use the Event and Custom Event Utilities, include the following source
  files in your web page with the <code>script</code> tag: </p>
  
  <pre><textarea name="code" class="HTML" cols="60" rows="1">
&lt;!-- Dependency --&gt; 
&lt;script type="text/javascript" src="http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/yahoo/yahoo-min.js" &gt;&lt;/script&gt;

&lt;!-- Event source file --&gt;
&lt;script type="text/javascript" src="http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/event/event-min.js" &gt;&lt;/script&gt;
</textarea></pre>
<?php
include "../inc/include-notice.inc";
?>

<p>The Event and Custom Event components are defined by <code>YAHOO.util.Event</code> and
  <code>YAHOO.util.CustomEvent</code>, respectively. </p>
<h3>Basic Events</h3>
<p>To attach an event handler to the DOM, simply define your event handler and pass the event handler to the Event Utility along with a reference to the event for which you want to listen and the element to which you want attach the handler: </p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
var oElement = document.getElementById("elementid");
function fnCallback(e) { alert("click"); }
YAHOO.util.Event.addListener(oElement, "click", fnCallback);
</textarea></pre>

    <p>These lines of code:</p>
    <ul>
        <li>Declare a variable <code>oElement</code> and assign a specific element in the DOM to
          that variable.</li>
        <li>Define a callback function, <code>fnCallback(e)</code>, to handle  the specified
          event.</li>
        <li>Call the <code>addListener</code> method on the <code>YAHOO.util.Event</code> object to 
          bind an event to the DOM element. The <code>addListener</code> method requires three
          arguments: the element the event is bound to (<code>oElement</code>), the event
          to bind (<code>"click"</code>, as a string), and the callback function  (<code>fnCallback</code>).</li>
  </ul>
    <p>
    To attach an event handler by element ID, use this code: </p>
    <pre><textarea name="code" class="JScript" cols="60" rows="1">
function fnCallback(e) { alert("click"); }
YAHOO.util.Event.addListener("elementid", "click", fnCallback);
</textarea></pre>

    <p>This example is similar to the first.  However, in this case we are identifying the element by its HTML ID (<code>"elementid"</code> as a string) rather than by passing in a variable pointing to the element object. The Event Utility attempts to find the DOM element by this id value; should it fail to find the element immediately, it continues to seek the element for up to 15 seconds after the page has loaded. This "automatic deferral" enables you, in many cases, to write your event attachment code directly into your script rather than separating it out in a function that runs only after the page has loaded.</p>
    <p>
    To attach an event handler to multiple elements, use this code:     </p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
// array can contain object references, element ids, or both
var ids = ["el1", "el2", "el3"];
function fnCallback(e) { alert(this.id); }
YAHOO.util.Event.addListener(ids, "click", fnCallback);
</textarea></pre>
    
    
    
    <p>These lines: </p>
    <ul>
        <li>Declare an array of ids corresponding to the HTML ID attributes of elements on the page. The array can contain HTML IDs as strings (as shown above); it can also accept variable object references.</li>
        <li>Define a callback function, <code>fnCallback(e)</code>, to handle the specified event.</li>
        <li>Call the <code>addListener</code> method of <code>YAHOO.util.Event</code> to bind an event to the
          DOM element. In this case the first argument to the <code>addListener</code> method
          is the ids array rather than a single element or ID. </li>
    </ul>
  <p>See the examples in <a href="#event">Using Event</a> and <a href="#customevent">Using
  CustomEvent</a> or the <a href="../docs/YAHOO.util.CustomEvent.html">API Documentation</a> for more details.  See also <a href="../examples/event/eventsimple.html">the first Event Utility example</a> for a tutorial on how to attach events using <code>addListener</code>.</p>
  
  <p><strong>Note:</strong> Developers often wonder where they can find a comprehensive list of DOM events (e.g., "click", "mousemove", etc.) that shows in which browsers each event is supported. As far as we know, no perfect list exists.  Danny Goodman's <em><a href="http://www.oreillynet.com/catalog/9780596527402/">DHTML: The Definitive Reference</a></em> may have the most comprehensive information of this kind; PPK's <a href="http://www.quirksmode.org/dom/events/">Event Compatibility Table</a> on quirksmode may have the best compatibility assessment online.  The Event Utility does not place any constraints on the events for which you attach handlers; it will attempt to attach listeners for any event name you provide.  It's your responsibility to make sure that the event you're using is one that is supported in the browsers for which you're developing.</p>

<h2 id="event">Using Event</h2>

  <p>This section describes several common features and uses of the Event Utility.  It contains these sections: </p>
  <ul>
    <li><a href="#deferral">Handler Attachment Deferral</a></li>
    <li><a href="#scope">Automatic Scope Correction</a></li>

    <li><a href="#abstraction">Automatic Event Object Browser Abstraction</a></li>
    <li><a href="#customobject">Send an Arbitrary Object to the Event Handler</a></li>

  </ul>

<h3 id="deferral">Handler Attachment Deferral</h3>

<p>
If you attempt to attach a handler to an element before the page is fully loaded,
  the Event Utility attempts to locate the element. If the element is not
  available, Event periodically checks for the element until the <code>window.onload</code>
  event is triggered. Handler deferral only works when attaching handlers by
  element id; if you attempt to attach to a DOM object reference that is not
  yet available, the component has no way of knowing what object you are trying
  to access.
</p>

<h3 id="scope">Automatic Scope Correction</h3>
<p>
Event handlers added with Internet Explorer's <code>attachEvent</code> method are executed
  in the <code>window</code> scope, so the special variable <code>this</code> in your callback references
  the <code>window</code> object. This is not very useful. Even more vexing is the fact that
  the event object in Internet Explorer does not provide a reliable way of identifying
  the element on which the event was registered; standards-based browsers supply
  this as the <code>currentTarget</code> property, but this property is not present in IE.</p>
  <p>By default, the Event Utility automatically adjusts the execution scope so that <code>this</code>
  refers
  to the DOM element to which the event was attached, conforming to the
  behavior of <code>addEventListener</code> in W3C-compliant browsers. Moreover, the event
  subscriber can override the scope so that <code>this</code> refers to a <a
  href="#customobject">custom object</a> passed into the <code>addListener</code> call.
  </p>

<h3>Automatic Event Object Browser Abstraction <a name="abstraction"></a></h3>
<p>
The first parameter your callback receives when the event fires is always the
actual event object.  There is no need to look at <code>window.event</code>.
</p>

<h3 id="customobject">Send an Arbitrary Object to the Event Handler</h3>
<p>
It is common in object-oriented JavaScript development to assign a custom object's member method to listen for
  an event, access internal properties and execute internal methods in
  response.  Because the event handler is (by default) executed in the scope of
  the element, not in the scope of the listener method's parent object, the
  custom object's properties are not available through the <code>this</code> property as
  one might expect. You can work around this in a number of ways: (1) by creating
  closures or (2) creating circular references between your custom object and the
  element.</p>

<p>The
Event Utility  enables you to pass your custom objects directly to the event
handler so you don't have to use any of these (potentially leaky) methods to
gain access to that custom object. Pass your custom object as
the fourth parameter to the <code>addListener</code> method, and that object is passed in
as the second parameter to your callback function (the first is the event object itself):
</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
function MyObj(elementId, customProp, callback) {
   this.elementId = elementId;
   this.customProp = customProp;
   this.callback = callback;
}

MyObj.prototype.addClickHandler = function() {
   YAHOO.util.Event.addListener(this.elementId, "click", this.callback, this);
};

function fnCallback1(e, obj) {
  // the execution context is the html element ("myelementid")
  alert(this.id + " click event: " + obj.customProp);
}

function fnCallback2(e, obj) {
  // the execution context is the custom object
  alert("click event: " + this.customProp);
}

var myobj = new MyObj("myelementid", "hello world", fnCallback1);
var mydata = {id: 10 };

// One way to add the handler:
myobj.addClickHandler();

// This will do the same thing:
YAHOO.util.Event.addListener("myelementid", "click", fnCallback1, myobj);

// If we pass true as the final parameter, the custom object that is passed
// is used for the execution scope (so it becomes "this" in the callback).
YAHOO.util.Event.addListener("myelementid", "click", fnCallback2, myobj, true);


// Alternatively, we can assign a completely different object to be the
// execution scope:
YAHOO.util.Event.addListener("myelementid", "click", fnCallback2, mydata, myobj);

</textarea></pre>

<h2 id="removeevent">Removing Events</h2>

<p>You can remove event listeners by calling <code>YAHOO.util.Event.removeListener</code> with the same event
signature that you used to create the event.</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
YAHOO.util.Event.removeListener("myelementid", "click", fnCallback1);
</textarea></pre>

<p>If it is not convenient to save a reference to the original callback you
used to register the event, and you know you are the only listener to the
event, you can call <code>removeListener</code> without the function argument.  Doing so
will remove all listeners added via <code>addListener</code> for the specified element and event type.
</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
YAHOO.util.Event.removeListener("myelementid", "click");
</textarea></pre>



<p><code>YAHOO.util.Event.getListeners</code> lets you retrieve all of the listeners that were attached to an element via
<code>addListener</code>.  Optionally, you can retrieve all bound listeners of a given type:
</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
// all listeners
var listeners = YAHOO.util.Event.getListeners(myelement);
for (var i=0; i<listeners.length; ++i) {
    var listener = listeners[i];
	alert( listener.type   ); // The event type
	alert( listener.fn     ); // The function to execute
	alert( listener.obj    ); // The custom object passed into addListener
	alert( listener.adjust ); // Scope correction requested, if true, listener.obj
                              // is the scope, if an object, that object is the scope
}

// only click listeners 
var listeners = YAHOO.util.Event.getListeners(myelement, "click");

</textarea></pre>

<p><code>YAHOO.util.Event.purgeElement</code> lets you remove all listeners that were registered via <code>addListener</code> from an element.
Optionally, a specific type of listener can be specified. In addition, The element's children can
also be purged.
</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
// all listeners
YAHOO.util.Event.purgeElement(myelement);
// all listeners and recurse children
YAHOO.util.Event.purgeElement(myelement, true);
// only click listeners
YAHOO.util.Event.purgeElement(myelement, false, "click");

</textarea></pre>

<h2 id="onavailable">Using the onAvailable and onContentReady Methods</h2>
<p><code>onAvailable</code> lets you define a function that will execute as soon as an element
  is detected in the DOM. The intent is to reduce the occurrence of timing issues
  when rendering script and html inline. It is not meant to be used to define
  handlers for elements that <em>may</em> eventually be in the document; it is meant to
  be used to detect elements you are in the process of loading.
</p>
<p>
    The argument signature for <code>onAvailable</code> is similar to that of <code>addListener</code>, omitting only the event type.
</p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
 &lt;script type="text/javascript"&gt;

 function TestObj(id) {
   YAHOO.util.Event.onAvailable(id, this.handleOnAvailable, this); 
 }

 TestObj.prototype.handleOnAvailable = function(me) {
   alert(this.id + " is available");
 }

 var obj = new TestObj("myelementid");
 &lt;/script&gt;

 &lt;div id="myelementid"&gt;my element&lt;/div&gt;

</textarea></pre>

<p>The <code>onContentReady</code> method shares an identical syntax with <code>onAvailable</code>.  The material difference between the two methods is that <code>onContentReady</code> waits until both the target element and its <code>nextSibling</code> in the DOM respond to <code>getElementById</code>.  This guarantees that the target element's contents will have loaded fully (excepting any dynamic content you might add later via script).  If <code>onContentReady</code> never detects a <code>nextSibling</code>, it fires with the <code>window.load</code> event.</p>

<h2 id="ondomready">Using the onDOMReady Method</h2>
<p><code>onDOMReady</code> lets you define a function that will execute as soon as the DOM is in a usable state.  The DOM is is not deemed "usable" until it is structurally complete; a number of bugs, primarily in IE, can lead to the browser crashing or failing to load the page successfully if scripts attempt to insert information into the DOM prior to the DOM being in a complete state.</p>

<p>DOM readiness is achieved before images have finished loading, however, so <code>onDOMReady</code> is often an excellent alternative to using the <code>window</code> object's <code>load</code> event.</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
 &lt;script type="text/javascript"&gt;

 function init() {
    YAHOO.util.Dom.setStyle("hidden_element", "visibility", "");
 }
 YAHOO.util.Event.onDOMReady(init);

 // As with addListener, onAvailable, and onContentReady, you can pass a data object and adjust the scope
 // YAHOO.util.Event.onDOMReady(init, data, scope);

 &lt;/script&gt;
</textarea></pre>


<h2 id="customevent">Using the CustomEvent Object </h2>
<p>The CustomEvent object enables you to define and use events not available
  by default in the DOM &mdash; events that are specific to and of interest in your own
  application. This section describes several common uses of the CustomEvent component and provides some examples.  It contains these sections: </p>
<ul>
<li> <a href="#customdefine">Defining a Custom Event </a></li>
<li> <a href="#customsubscribe">Subscribing (Listening) to a Custom Event </a></li>
<li> <a href="#customcallback">Creating a Callback </a></li>
<li><a href="#customfire"> Triggering the Event </a></li>
</ul>

<h3 id="customdefine">Defining a Custom Event</h3>
<p>To define a custom event type, create a new instance of CustomEvent: </p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
// custom object
function TestObj(name) {
    this.name = name;
    // define a custom event
    this.event1 = new YAHOO.util.CustomEvent("event1", this);
}
</textarea></pre>

<p>
The CustomEvent constructor creates a new Custom Event; it takes one required parameter and three optional parameters:
</p>
  
<ul>
<li><strong>type</strong> &mdash; The type of event. This string is returned to listeners
  that receive this event so that they know what event occurred.</li> 
 <li><strong>scope</strong> &mdash; The scope in which listener methods should fire; if you do
  not specify a scope here, the default scope will be the <code>window</code> object.</li>
  <li><strong>silent</strong> &mdash; false by default.  If true, the activity for this event will
      not be logged when in debug mode.</li>
  <li><strong>signature</strong> &mdash; specifies the signature for the event listeners.  The choices are:
     <ul>
     <li><code>YAHOO.util.CustomEvent.LIST</code> (the default): 
       <ul>
       <li><strong>param1:</strong> event name</li>
       <li><strong>param2:</strong> array of arguments sent to fire</li>
       <li><strong>param3:</strong> (optional) a custom object supplied by the subscriber</li>
       </ul>
     </li>
     <li><code>YAHOO.util.CustomEvent.FLAT</code>
       <ul>
       <li><strong>param1:</strong> the first argument passed to fire.  If you need to
               pass multiple parameters, use and array or object literal</li>
       <li><strong>param2:</strong> <optional> a custom object supplied by the subscriber</li>
       </ul>
     </li>
     </ul>
  </li>
  
  </ul>
<p>
The event subscriber can override the scope so that <code>this</code> refers to the custom object that was passed into the <code>subscribe</code> method.
</p>

<h3 id="customsubscribe">Subscribing (Listening) to a Custom Event</h3>
<p>To subscribe to a custom event, use its <code>subscribe</code> method: </p>
<pre><textarea name="code" class="JScript" cols="60" rows="1">
// a custom consumer object that will listen to "event1"
function Consumer(name, testObj) {
    this.name = name;
    this.testObj = testObj;
    this.testObj.event1.subscribe(this.onEvent1, this);
}
</textarea></pre>

<p>
In this example, <code>event1</code> is the Custom Event object that was created in the previous
  section. Use the <code>subscribe</code> method to listen to that event. The <code>subscribe</code> method
  takes two parameters. The first  is the callback; the second is a custom
  object you can define (see <a href="#customobject">Send an Arbitrary Object
  to the Event Handler</a>, earlier in this document). When the event is triggered, the callback is called
  and the custom object is passed to that callback as the third argument (when using the default argument signature; when using the flat signature, the custom object is the second argument). </p>
<h3 id="customcallback">Creating a Callback</h3>
<p>To create a callback for a custom event: </p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
Consumer.prototype.onEvent1 = function(type, args, me) {
    alert(" this: " + this +
          "\n this.name: " + this.name +
          "\n type: " + type +
          "\n args[0].data: " + args[0].data +
          "\n me.name: " + me.name);
}
</textarea></pre>

<p>
In this example the type argument is the event type (<code>"event1"</code> in this case),
args is an array of all of the arguments that were passed to the Custom Event's
<code>fire</code> method, and <code>me</code> is the custom object we passed in when we subscribed to
the event.
</p>
<h3 id="customfire">Triggering the Event</h3>
<p>To trigger or <code>fire</code> a custom event: </p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
// random test data to be used as an event argument
function TestData(data) {
    this.data = data;
}

// create an instance of our test object
var t1 = new TestObj("mytestobj1");

// create the event consumer, passing in the custom 
// object so that it can subscribe to the custom event
var c1 = new Consumer("mytestconsumer1", t1);

// create a data object that will be passed to the consumer when the event fires
var d1 = new TestData("mydata1");

// fire the test object's event1 event, passing the data object as a parameter
t1.event1.fire(d1);
</textarea></pre>

<p>
In this example <code>t1</code> is the test object we created, <code>event1</code> is the CustomEvent instance
  and <code>d1</code> is our test data. This example produces the following output:
</p>

<pre><textarea name="code" class="JScript" cols="60" rows="1">
 this: [object Object]
 this.name: mytestobj1
 type: event1
 args[0].data: mydata1
 me.name: mytestconsumer1
</textarea></pre>

<?php include "../inc/mobileSection.inc";?>

<p>The Event Utility works in any browser that has DOM2 event support.
However, the user interaction model of mobile browsers can make certain browser
events behave in a different manner than expected, or not at all.</p>

<p>The iPhone's touch interface supports gestures that prevent
certain mouse events from working correctly.  For instance, the 'mousedown'
event does not fire when the user initially touches the screen over an element.
It only fires once the user's finger is removed (the mousedown, mouseup, and
click events all fire at this moment).  This makes is difficult or impossible
to provide certain DHTML interactions that rely on these events, drag and drop
being the most obvious.</p> 

<p>Since the iPhone has a touch interface, there is
no mouse cursor.  This means that there are no hover states for elements, and
no mouseover events.</p>


<?php include "../inc/support.inc"; ?>

	  </div>
         <div class="yui-u">
		 	
			<div id="cheatsheet">
				<h3>Event Utility Cheat Sheet:</h3>
				
				<a href="http://yuiblog.com/assets/pdf/cheatsheets/event.pdf"><img src="http://us.i1.yimg.com/us.yimg.com/i/ydn/yuiweb/img/cheatsheet-images/event.gif" width="178" height="134" alt="Cheat Sheet for Event Utility and Custom Events."></a>
				
				<p><a href="/yui/docs/assets/cheatsheets.zip">Download full set of cheat sheets.</a></p>
			</div>
			
			<div id="examples">
<?php 
	include("../inc/examplesNav/".$section.".inc");
?>
		   </div>
	 
			<div id="morereading">
				<h3>More Reading about Dom Events and the YUI Event Utility:</h3>
				
			  <ul> 
			  	  <li><a href="http://www.quirksmode.org/dom/events/">Event Compatibility Tables</a>, by PPK (quirksmode); a list of basic DOM events that breaks out their compatibility by browser version</li>
				  <li><a href="http://yuiblog.com/blog/2007/01/17/event-plan/">Event-Driven Application Design</a>, by Christian Heilmann</li>
				  <li><a href="http://icant.co.uk/sandbox/eventdelegation/">Event Delegation versus Event Handling</a>, by Christian Heilmann</li>
				  <li><a href="http://www.dustindiaz.com/yahoo-event-utility/">Forget addEvent, use Yahoo!'s Event Utility</a>, by Dustin Diaz</li>
				  <li><a href="http://www.klauskomenda.com/archives/2007/10/14/agent-yui-mission-1-attaching-events-the-easy-way/">Agent YUI: Mission 1 &mdash; Attaching Events (the easy way)</a>, by Klaus Komenda</li>
		      </ul>
		   </div>

<?php 
$thisURI="http://developer.yahoo.com/yui/event/";
require_once('../inc/badge.inc');
?>
<h3 id="delicious">YUI Event on del.icio.us:</h3>
<div class="delicious">
<?php require('../inc/badge-html.inc'); ?>
</div>

		 </div>
      </div>

</div>
</div>

<?php include "../inc/side.inc" ?>
<?php include "../inc/footer.inc" ?>


