<?php
$title="Yahoo! UI Library: Connection Manager";
$section="connection";
$component="Connection Manager";
$highlightSyntax = true;
$releasenotes = true;
include "../inc/header.inc";
?>

<div id="yui-main">
<div class="yui-b">
  <div class="yui-ge">
      <div class="yui-u first">

  <div id="promo" class="component">
    <h1>Connection Manager</h1>
    <p>Connection Manager is a utility that enables you to make in-page HTTP requests through a simplified interface to the XMLHttpRequest object. XMLHttpRequest is the mechanism commonly referred to as "Ajax," allowing your scripts to communicate with the server without a page reload, persisting the user interface across many client-server interactions. Connection Manager handles cross-browser instantiation of XMLHttpRequest, negotiates the server response and uses a callback pattern to process the response data.</p>
    <div>
      <h4>On This Page:</h4>
      <ul>
        <li><a href="#start">Getting Started</a></li>
        <li><a href="#using">Using Connection Manager</a></li>
        <li><a href="#issues">Known Issues</a></li>
        <li><a href="#support">Support &amp; Community</a></li>
		<li><a href="#filingbugs">Filing Bugs and Feature Requests</a></li>
      </ul>
    </div>

<?php
include('../inc/quicklinks.inc');
?>

  </div>
  <h2 class="first"><a name="start"></a>Getting Started</h2>
  <p>To use Connection Manager, include the source file and its dependency in your web page with the script tag: </p>
<textarea name="code" class="HTML" cols="60" rows="1">
<!-- Dependency -->
<script src="http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/yahoo/yahoo-min.js"></script>

<!-- Used for Custom Events and event listener bindings -->
<script src="http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/event/event-min.js"></script>

<!-- Source file -->
<script src="http://yui.yahooapis.com/<?php echo($yuiCurrentVersion);?>/build/connection/connection-min.js"></script>
</textarea>
<?php
include "../inc/include-notice.inc";
?>

  <p>The following simple example initiates an asynchronous transaction using the Connection Manager utility.</p>
<textarea name="code" class="JScript" cols="60" rows="1">
<script>
var transaction = YAHOO.util.Connect.asyncRequest('GET', sUrl, callback, null);
</script>
</textarea>
  <p>In this code:</p>
  <ul>
    <li>The YAHOO.util.Connect.asyncRequest method initiates an asynchronous transaction (using XMLHttpRequest) and returns a reference to that transaction.</li>
    <li>The first argument of asyncRequest specifies the HTTP method; this transaction uses HTTP GET.  Other possible methods include: POST, HEAD, PUT, DELETE(HEAD, PUT and DELETE may not be supported by all A-Grade browsers ).</li>
    <li>The second argument &mdash; variable sUrl &mdash; is a qualified URL.</li>
    <li>The third argument &mdash; variable callback &mdash; is a reference to a defined callback object(or an object written inline), which handles the server response.</li>
    <li>The fourth argument accommodates a POST message for POST transactions.
      Because this example illustrates a GET transaction, the POST message argument can be ignored or set to
      null. </li>
  </ul>
  <h2><a name="using"></a>Using Connection Manager</h2>
  <p>This section describes several common uses of the Connection Manager.  It contains these subsections:</p>
  <ul>
   <li><a href="#async">Asynchronous Transactions and the Callback Object</a></li>
<li> <a href="#cache">Override Caching</a></li>
<li> <a href="#file">The Callback Object and File Upload </a></li>
<li> <a href="#scope">The Callback Object and Scope </a></li>
<li> <a href="#timeout">The Callback Object and Timeout </a></li>
 <li> <a href="#success">Success Case</a></li>
 <li> <a href="#failure">Failure Case</a></li>
 <li> <a href="#upload">Upload Case</a></li>
 <li> <a href="#forms">Forms and File Upload</a></li>
 <li> <a href="#customevents">Custom Events</a></li>
 <li> <a href="#requestsignatures">Request Signatures</a></li>
 <li> <a href="#status">Transaction Status</a></li>

  </ul>

  <h3>Asynchronous Transactions and the Callback Object<a name="async"></a></h3>
  <p>In an asynchronous transaction, you create a callback object to handle
    the server response and its associated data. You may omit the callback object
    if you don't care what information comes back from the server; all of the
    callback object's members are optional. However, in most cases you should
    supply at least three members in your callback object:</p>
  <ul>
    <li><strong>success</strong>: a function called when the server responds
      with a valid HTTP response.</li>
    <li><strong>failure</strong>: a function called when the server response
      indicates that a problem, such as an HTTP 404 (file not found) error, has
      occurred.</li>
    <li><strong>argument</strong>: an object, string, number, or array containing data that your success and failure functions might need in order to successfully process the server response.</li>
  </ul>
  <p>When reconciling a transaction, Connection Manager will evaluate the HTTP code returned by the server to determine if the request was successful and will then call the appropriate callback handler (<code>success</code> or <code>failure</code>).  You can also define the callback object's <code>argument</code> member to pass an argument or collection of arguments to both the <code>success</code> and <code>failure</code> handler.</p>
<textarea name="code" class="JScript" cols="60" rows="1">
/*
 * This is an example callback object with success
 * and failure members defined inline.  The argument
 * property demonstrates how to pass multiple values
 * to the callback as an array.
 */
var callback =
{
  success: function(o) {/*success handler code*/},
  failure: function(o) {/*failure handler code*/},
  argument: [argument1, argument2, argument3]
}
</textarea>
  <p>The example that follows shows in more detail how to construct
    a callback object with two members: success and failure, to handle the server
    response. In this example, the <code>success</code> and <code>failure</code> members
    are defined by the <code>responseSuccess</code> and <code>responseFailure</code>
    functions respectively.
    These handler functions accept the response object <code>o</code> from
    Connection Manager.</p>
<textarea name="code" class="JScript" cols="60" rows="1">
// Passing an example of array of arguments to both
// the success and failure callback handlers.
var args = ['foo','bar'];

var responseSuccess = function(o){
/* Please see the Success Case section for more
 * details on the response object's properties.
 * o.tId
 * o.status
 * o.statusText
 * o.getResponseHeader[ ]
 * o.getAllResponseHeaders
 * o.responseText
 * o.responseXML
 * o.argument
 */
};

var responseFailure = function(o){
// Access the response object's properties in the
// same manner as listed in responseSuccess( ).
// Please see the Failure Case section and
// Communication Error sub-section for more details on the
// response object's properties.
}

var callback =
{
  success:responseSuccess,
  failure:responseFailure,
  argument:args
};
</textarea>

  <h3>Override Caching<a name="cache"></a></h3>
  <p>
  Connection Manager can append a timestamp parameter to an HTTP GET request querystring, configured through the callback object, to override the caching behavior of HTTP GET.  This will produce a key-value of <code>rnd=timestamp</code> in the querystring.  NOTE: By using this feature, HTTP GET requests become non-idempotent and and the presence of this key-value in the querystring may produce side effects.  Additionally, Web servers/services can respond with the appropriate HTTP responses headers to prevent the resource from being cached.
  </p>
<textarea name="code" class="JScript" cols="60" rows="1">
/*
 * Set callback.cache to false to override HTTP GET caching.
 * A key-value of rnd=timestamp will be added to the
 * querystring.
 */
var callback =
{
  cache:false
}
</textarea>

<h3> The Callback Object and File Upload <a name="file"></a></h3>
<p>
When uploading files using <code>YAHOO.util.Connect.setForm</code>, the callback object will require an <code>upload</code> handler instead of
<code>success</code> and, or <code>failure</code> handlers.  For more details, please see <a href="#upload">Upload Case</a> and <a href="#forms">Forms and File Upload</a>.</p>
<textarea name="code" class="JScript" cols="60" rows="1">
/*
 * This is an example callback object with upload
 * and argument members defined inline.  The argument
 * property demonstrates how to pass multiple values
 * to the upload handler as an array.
 */
var callback =
{
  upload: function(o) {/*upload handler code*/},
  argument: [argument1, argument2, argument3]
}
</textarea>


<h3> The Callback Object and Scope <a name="scope"></a></h3>
  <p> When an object's method is used as the success or failure handler in a
    callback, any usage of the <code>this</code> keyword in
    the method loses scope. While this can be partially resolved by passing a
    reference to the handler's parent object as a user-defined argument, it still
  invalidates the use of <code>this</code> within the handler itself.  To use
  an object's method as a callback handler and maintain scope within the member,
  define the callback member <code>scope</code> with a value of <code>this</code>. </p>
  <textarea name="code" class="JScript" cols="60" rows="1">

/*
 * AjaxObject is a hypothetical object that encapsulates the transaction
 *     request and callback logic.
 *
 * handleSuccess( ) provides success case logic
 * handleFailure( ) provides failure case logic
 * processResult( ) displays the results of the response from both the
 * success and failure handlers
 * call( ) calling this member starts the transaction request.
 */

var AjaxObject = {

	handleSuccess:function(o){
		// This member handles the success response
		// and passes the response object o to AjaxObject's
		// processResult member.
		this.processResult(o);
	},

	handleFailure:function(o){
		// Failure handler
	},

	processResult:function(o){
		// This member is called by handleSuccess
	},

	startRequest:function() {
	   YAHOO.util.Connect.asyncRequest('POST', 'php/post.php', callback, "new=1&old=2");
	}

};

/*
 * Define the callback object for success and failure
 * handlers as well as object scope.
 */
var callback =
{
	success:AjaxObject.handleSuccess,
	failure:AjaxObject.handleFailure,
	scope: AjaxObject
};

// Start the transaction.
AjaxObject.startRequest();
</textarea>

<h3>The Callback Object and Timeout <a name="timeout"></a></h3>
  <p>
     Each transaction can be defined with a time threshold and if the transaction has not completed by that threshold, it will automatically call <code>abort</code>.  If successful, the <code>failure</code> handler will be called.  Please see section Failure Case for more details on the response object signature in an abort scenario.
  </p>
	<textarea name="code" class="JScript" cols="60" rows="1">
	/*
	 * In this example, the callback object has a new property:
	 * timeout.  This property is defined with a value,
	 * in milliseconds, of 5000 as the abort threshold.  If
	 * the transaction has not completed by 5000ms, the
	 * transaction will abort.
	 */
	var callback =
	{
	  success: function(o) {/*success handler code*/},
	  failure: function(o) {/*failure handler code*/},
	  timeout: 5000,
	  argument: [argument1, argument2, argument3]
	}
	</textarea>


  <h3>Success Case<a name="success"></a></h3>
  <p> In a success case, a response object with the following properties is passed to the callback object's success handler: </p>
   <div class="apisummary short"><table>
    <tr>
      <th>property</th>
      <th>description</th>
    </tr>
    <tr class="odd">
      <td>tId</td>
      <td>The unique, incremented id for the transaction.</td>
    </tr>
    <tr>
      <td>status</td>
      <td>The HTTP status code of the resulting transaction.</td>
    </tr>
    <tr class="odd">
      <td>statusText</td>
      <td>The message associated with the HTTP status.</td>
    </tr>
    <tr>
      <td>getResponseHeader[<em>label</em>]</td>
      <td>Returns the string value of the specified header label.</td>
    </tr>
    <tr class="odd">
      <td>getAllResponseHeaders</td>
      <td>All returned HTTP headers available as a string.  Each label-value pair is delimited by "\n".</td>
    </tr>
    <tr>
      <td>responseText</td>
      <td>The server's response as a string.</td>
    </tr>
    <tr class="odd">
      <td>responseXML</td>
      <td>The server's response as a XML document.</td>
    </tr>
    <tr>
      <td>argument</td>
      <td>The user-defined argument or arguments as defined in the callback object.</td>
    </tr>
  </table></div>
  <h3> Failure Case<a name="failure"></a></h3>
  <p> If the server responds with an error or fails to respond at all, Connection
    Manager tries to capture as much information as possible about the transaction
  and pass an object to the callback object's <code>failure</code> handler.
  The properties of this response object are the same as in a success case &mdash; Connection
  Manager  populates all properties for which it can derive adequate information
  from the server's response. </p>
  <p> If the server cannot or does not respond to the HTTP request, however,
    there may not be a readable response. If a transaction is terminated by the
    server in such a way that no readable response is available, the callback
    object's failure handler receives an object with the following properties:</p>
  <div class="apisummary short"><table>
    <tr class="odd">
      <th>property</th>
      <th>description</th>
    </tr>
    <tr>
      <td>tId</td>
      <td>The transaction id</td>
    </tr>
    <tr class="odd">
      <td>status</td>
      <td>0</td>
    </tr>
    <tr>
      <td>statusText</td>
      <td>"communication failure"</td>
    </tr>
    <tr class="odd">
      <td>argument</td>
      <td>The user-defined argument or arguments as defined as the callback object.</td>
    </tr>
  </table></div>

  <p> If an <code>abort</code> occurred and the transaction was successfully cancelled, the callback object's failure handler receives an object with the following properties:</p>
  <div class="apisummary short"><table>
    <tr class="odd">
      <th>property</th>
      <th>description</th>
    </tr>
    <tr>
      <td>tId</td>
      <td>The transaction id</td>
    </tr>
    <tr class="odd">
      <td>status</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>statusText</td>
      <td>"transaction aborted"</td>
    </tr>
    <tr class="odd">
      <td>argument</td>
      <td>The user-defined argument or arguments as defined as the callback object.</td>
    </tr>
  </table></div>

  <h3> Upload Case<a name="upload"></a></h3>
  <p>
  	Since file uploading occurs through an iframe, traditional response data such as HTTP status codes are not directly available, and connection manager cannot reasonably discern success or failure.  Instead, the callback's upload handler will receive a response object containing the body of the iframe document, as a string, when the transaction is complete.  Rather than enforce a document pattern, you can customize the upload response to contain the necessary markup and, or script.
  </p>

  <div class="apisummary short"><table>
    <tr class="odd">
      <th>property</th>
      <th>description</th>
    </tr>
    <tr>
      <td>tId</td>
      <td>The transaction id</td>
    </tr>
    <tr class="odd">
      <td>responseText</td>
      <td>The markup, within the iframe document's body tag, as a string, if available</td>
    </tr>
    <tr>
      <td>responseXML</td>
      <td>The response data as an XML document, if available.</td>
    </tr>
    <tr class="odd">
      <td>argument</td>
      <td>The user-defined argument or arguments as defined as the callback object.</td>
    </tr>
  </table></div>

  <h3><a name="forms"></a>Forms and File Upload</h3>
  <p>Connection Manager can automatically harvest HTML form data and prepare
    it for either a GET or POST request via the <code>setForm</code> method.
    When you call this method before initiating the transaction, Connection Manager
    constructs a GET querystring or a POST message from the form
    and submits it to the specified URL. To use this functionality, your form
    elements must have defined, non-empty string name attribute values.
    </p>

   <p>
   If the subsequent <code>asyncRequest</code> is HTTP GET and has a URI querystring, the querystring resulting from <code>setForm</code> will be concatenated onto the URI's existing querystring.
   If the transaction is HTTP POST, and <code>asyncRequest</code> contains additional POST data -- as the fourth argument -- this data will be added to the form data to create the POST message.
   </p>
  <textarea name="code" class="JScript" cols="60" rows="1">
// argument formId can be the id or name attribute value of the
// HTML form, or an HTML form object.
var formObject = document.getElementById('aForm');
YAHOO.util.Connect.setForm(formObject);
// This example facilitates a POST transaction.
// An HTTP GET can be used as well.
var cObj = YAHOO.util.Connect.asyncRequest('POST', 'http://www.yahoo.com', callback);
</textarea>
   <p>
   	<code>setForm</code> can also upload files, if form elements of <em>input type="file"</em> are present, as part of a form submission.  To enable file uploading, set the second argument of <code>setForm</code> to true. When the transaction is complete, the callback object's upload method will be called.
   </p>
   <textarea name="code" class="JScript" cols="60" rows="1">
   // argument formId can be the id or name attribute value of the
   // HTML form, or an HTML form object.
   var formObject = document.getElementById('aForm');

   // the second argument is true to indicate file upload.
   YAHOO.util.Connect.setForm(formObject, true);

   var cObj = YAHOO.util.Connect.asyncRequest('POST', 'http://www.yahoo.com', callback);
   </textarea>

   <p>
     When uploading files in applications over SSL and using IE, set the third argument to <em>true</em> to prevent IE from throwing domain security errors.
   </p>
   <textarea name="code" class="JScript" cols="60" rows="1">
   // the third argument is set true to have Connection Manager
   // set the iframe source to "javascript:false".
   YAHOO.util.Connect.setForm(formObject, true, true);
   </textarea>

<h3>Transactions and Custom Events<a name="customevents"></a></h3>
<p>
Connection Manager implements <code>YAHOO.util.CustomEvent</code> to provide a variety of custom events during the course of a transaction. The following table describes the list of Connection Manager's custom events:
</p>
   <div class="apisummary short"><table>
    <tr>
      <th>Custom Event</th>
      <th>Description</th>
    </tr>
    <tr class="odd">
      <td>startEvent</td>
      <td>This event fires at the start of a transaction and passes the transaction's ID to its subscribed handler.</td>
    </tr>
    <tr>
      <td>completeEvent</td>
      <td>This event fires when a transaction response has completed and passes the transaction's ID to its subscribed handler.</td>
    </tr>
    <tr class="odd">
      <td>successEvent</td>
      <td>This event fires when a transaction response is complete and determined to be HTTP 2xx.  The response object is passed to successEvent's subscribed handler. This event is analogous to the callback success handler.  NOTE: This event does not fire for file upload transactions.</td>
    </tr>
    <tr>
      <td>failureEvent</td>
      <td>This event fires when a transaction response is complete and determined to be HTTP 4xx/5xx or if an HTTP status is unavailable.  The response object is passed to failureEvent's subscribed handler. This event is analogous to the callback failure handler.</td>
    </tr>
    <tr class="odd">
      <td>uploadEvent</td>
      <td>This event fires when a file upload transaction is complete.  This event fires only for file upload transaction, in place of successEvent and failureEvent.  The response object is passed to the uploadEvent's subscribed handler.  This event is analogous to the callback upload handler.</td>
    </tr>
    <tr>
      <td>abortEvent</td>
      <td>This event fires when a transaction's <a href="#timeout">callback.timeout</a> triggers an abort or explicitly via <code>YAHOO.util.Connect.abort().</code></td>
    </tr>
  </table></div>

<p>
Connection Manager custom events are fired at the global level and can also fire at the transaction level.  One common use case for subscribing to global events is where a set of common event handlers are created to respond to all possible custom events.  In such a scenario, subscribing to global events is quite simple.  The following example demonstrate how to subscribe to global custom events:
</p>

<textarea name="code" class="JScript" cols="60" rows="1">

// Create a shorthand for YAHOO.util.Connect
var YUC = YAHOO.util.Connect;

/*
 * Create an object to handle all of the Connection Manager custom events.
 *
 * NOTE: You can also choose to represent your event handlers as global
 * functions instead of object members, and omit the scope argument from
 * subscribe().
 */
var handleEvents = {
	start:function(eventType, args){
	// do something when startEvent fires.
	// Argument eventType will have a string value of: startEvent
	// Argument args is an array, and the response object will be the
    // first element in the array.  The response object will have one
    // property: tId (the transaction ID).
    },
    
	complete:function(eventType, args){
	// do something when completeEvent fires.
	},

	success:function(eventType, args){
	// do something when successEvent fires.
	},

	failure:function(eventType, args){
	// do something when failureEvent fires.
	},

	// Define this event handler for file upload transactions *only*.
	// This handler will not be used for any other transaction cases.
	upload:function(eventType, args){
	// do something when uploadEvent fires.
	},

	abort:function(eventType, args){
	// do something when abortEvent fires.
	}
};

/*
 * This example shows how to subscribe to all custom events fired at the
 * Connection Manager level.  When subscribed, the custom event will fire
 * for all transactions.
 */

// Subscribe to all custom events fired by Connection Manager.
// Pass in the *globalEvents* object as the second argument to provide
// the necessary scope correction for any usage of the *this* keyword
// in any of the handler functions.
YUC.startEvent.subscribe(handleEvents.start, handleEvents);
YUC.completeEvent.subscribe(handleEvents.complete, handleEvents);

// This event will not fire for file upload transactions.  Instead,
// subscribe to the uploadEvent.
YUC.successEvent.subscribe(handleEvents.success, handleEvents);

// This event will not fire for file upload transactions.  Instead,
// subscribe to the uploadEvent.
YUC.failureEvent.subscribe(handleEvents.failure, handleEvents);

// This event is fired only for file upload transactions in place of
// successEvent and failureEvent
YUC.uploadEvent.subscribe(handleEvents.upload, handleEvents);
YUC.abortEvent.subscribe(handleEvents.abort, handleEvents);

/*
 * NOTE: You do not need to pass a callback object to asyncRequest()
 * since your handlers are already subscribed at the Connection
 * Manager level.  The callback object omits any success or failure
 * logic since those cases are already available and subscribed to as
 * custom events.  You can still include callback.success and
 * callback.failure, and they will be processed; but, it will also be
 * a redundant action.
 */

var transaction = YUC.asyncRequest('GET', sUrl, { timeout: 3000 });
</textarea>

<p>
In additional to global custom events, the same events can be fired for specific transactions by defining custom event handlers in the <a href="#async">callback object</a>.  To subscribe to these custom events, create the member *customevents* in the callback object and create handlers for as many custom events as desired.  The following code example shows how to define <code>callback.customevents</code> and the callback signatures:
</p>

<textarea name="code" class="JScript" cols="60" rows="1">
var callback =
{
	customevents:{
		onStart:function(eventType, args) {
		  // eventType has a string value of "startEvent".
		  // args[0].tId is the integer transaction ID.
		  // args[1] contains the value of <code>callback.argument</code>, if callback.argument is defined.
		},
		onComplete:function(eventType, args) {
		  // eventType has a string value of "completeEvent".
		  // args[0].tId is the integer transaction ID.
		  // args[1] contains the value of <code>callback.argument</code>, if callback.argument is defined.
		},
		onSuccess:function(eventType, args) {
		  /*
		   * eventType has a string value of "successEvent".
		   * args[0] is the response object, which has the
		   * following properties:
		   *
		   * args[0].tId
		   * args[0].status
		   * args[0].statusText
		   * args[0].getResponseHeader[ ]
		   * args[0].getAllResponseHeaders
		   * args[0].responseText
		   * args[0].responseXML
		   * args[0].argument
		   */
		},
		onFailure:function(eventType, args) {
		  // eventType has a string value of "failureEvent".
		  // args[0] is the response object.
		},

        // Define this event handler for file upload transactions *only*.
        // This handler will not be used for any other transaction cases.
		onUpload:function(eventType, args) {
		  // eventType has a string value of "uploadEvent".
		  // args[0] is the response object.
		},
		onAbort:function(eventType, args) {
		  // eventType has a string value of "abortEvent".
		  // args[0].tId is the integer transaction ID.
		  // args[1] contains the value of <code>callback.argument</code>, if callback.argument is defined.
		},
	},
}
</textarea>

<p>
The following example demonstrates the creation of a specific object to handle custom events, and the creation of the callback object used in the transaction:
</p>

<textarea name="code" class="JScript" cols="60" rows="1">

/*
 * Create an event handler object to handle a transaction's custom events.
 *
 * NOTE: You can also choose to represent your event handlers as global
 * functions instead of object members, and omit the scope argument from
 * the callback.
 *
 * This example demonstrates a non-file upload transaction, hence the
 * handler onUpload is not defined.
 */
var handleEvent = {
	start:function(eventType, args){
	// do something when startEvent fires.
	},

	complete:function(eventType, args){
	// do something when completeEvent fires.
	},

	success:function(eventType, args){
	// do something when successEvent fires.
	},

	failure:function(eventType, args){
	// do something when failureEvent fires.
	},

	abort:function(eventType, args){
	// do something when abortEvent fires.
	}
};

/*
 * This example shows how to subscribe to all custom events.
 * Pass the *handleEvent* object as the second argument to provide
 * the necessary scope correction for any usage of the *this* keyword
 * in any of the handler functions.
 *
 * NOTE: All events are subscribed in this example, but you can choose
 * to subscribe to any combination of custom events desired.  None are
 * mandatory.
 */

// Define the scope property with a value of *handleEvent* to provide
// the necessary scope correction for any usage of the *this* keyword
// in any of the handler functions.

/* Callback object with custom events defined */
var callback = {
	customevents:{
		onStart:handleEvent.start,
		onComplete:handleEvent.complete,
		onSuccess:handleEvent.success,
		onFailure:handleEvent.failure,
		onAbort:handleEvent.abort
	},
	scope:handleEvent,
 	argument:["foo","bar","baz"]
};

var transaction = YAHOO.util.Connect.asyncRequest('GET', sUrl, callback);
</textarea>

  <h3>Using Request Signatures<a name="requestsignatures"></a></h3>
  <p>
  When using Connection Manager, there are some ways to ensure the transaction originated from your application instead of a forged request.  One practice involves the use of user-specific signatures in the transaction.  Your application server can generate a pre-computed signature for use when the client initiates a request.  The following example demonstrate the creation of signatures using PHP and MD5 hashing, and using YUI Connection Manager to initiate a transaction containing the signature.
  </p>
<textarea name="code" class="JScript" cols="60" rows="1">
<?
// $deleteRecordToken can be any additional, random sequence concatenated onto $username.
// to salt the string which is converted to an MD5 hash.
$transaction_signature = md5($username . $deleteRecordToken);
?>

<script>
/*
 * Create a custom header -- in this case "X-Signature" -- using
 * connection manager with the signature as its value, and initiate
 * the transaction.  The transaction is sent to "/delete_record.php".
 */
YAHOO.util.Connect.initHeader('X-Signature', '<? echo $transaction_signature ?>');
var request = YAHOO.util.Connect.asyncRequest('GET', '/delete_record.php', callback);
</script>
</textarea>
<p>
Upon receiving the request from the client, determine its authenticity by verifying the signature before taking action.  Perform the same hashing operation and compare it to the signature received.  If the signatures do not match, do not proceed with the intended operation.
</p>
<textarea name="code" class="JScript" cols="60" rows="1">
<?
$transaction_signature = md5($username . $deleteRecordToken);

if ($_SERVER['HTTP_X_SIGNATURE']  === $transaction_signature) {
  // proceed with delete operation
  // ...
} else {
  // there is a problem
  // ...
}
?>
</textarea>

<p>
Signatures can also be use with GET requests, sent as a query string or part of a query string.
</p>

<textarea name="code" class="JScript" cols="60" rows="1">
<?
$transaction_signature = md5($username . $deleteRecordToken);

// $uri is the resource and the querystring includes the
// signature.
$uri = '/delete_record.php?signature=' . $transaction_signature;
?>
<script>
var request = YAHOO.util.Connect.asyncRequest('GET', '<? echo $uri ?>', callback);
</script>
</textarea>

<p>
With POST requests, the signature is sent as part of the data.
</p>

<textarea name="code" class="PHP" cols="60" rows="1">
<?
$transaction_signature = md5($username . $updateRecordToken);
?>
<script>
// postData represents the data sent in the POST request,
// and the signature is sent as part of the POST message.
var request = YAHOO.util.Connect.asyncRequest('POST', '/update_record.php', callback, postData + '&signature=<? echo $transaction_signature ?>');
</script>
</textarea>

  <h3>Transaction Status<a name="status"></a></h3>
  <p> The method <code>isCallInProgress</code> can be used to determine if an asynchronous transaction
    has not yet completed. The method will return <code>true</code> if the transaction is still in progress. </p>
<textarea name="code" class="JScript" cols="60" rows="1">
//Initiate an asynchronous transaction.
var cObj = YAHOO.util.Connect.asyncRequest('GET','http://www.yahoo.com',callback);

//isCallInProgress will return true if the transaction has not been completed.
var callStatus = YAHOO.util.Connect.isCallInProgress(cObj);
</textarea>

<p>  To explicitly cancel a transaction in progress, call the <code>abort</code> method and pass the connection
  object &mdash; returned by <code>asyncRequest</code> &mdash; as an argument. <code>abort</code> will return true if the transaction was successfully aborted or false if the transaction has completed before the abort call.</p>

<textarea name="code" class="JScript" cols="60" rows="1">
//Initiate an asynchronous transaction.
var cObj = YAHOO.util.Connect.asyncRequest('GET', sUrl, callback);

//Abort the transaction if it isn't completed in ten seconds.
setTimeout("YAHOO.util.Connect.abort(cObj)",10000);
</textarea>

<p>To use the transaction's callback failure handler upon <code>abort</code>, add the callback object as the second argument.</p>

<textarea name="code" class="JScript" cols="60" rows="1">
/*
 * Abort the transaction if it isn't completed in ten seconds,
 * and pass the callback with a defined failure handler as the
 * second argument.  The failure callback will receive a response
 * object with properties as described in the abort subsection of
 * Failure Case.
 *
 * abort() will return true if the transaction was successfully
 * aborted.  Otherwise, it will return false.
 *
 */
setTimeout("YAHOO.util.Connect.abort(cObj, callback)",10000);
</textarea>

<h2 id="issues">Known Issues</h2>

<p>In Firefox 3.0, all HTTP POST transactions automatically receive a <code>Content-Type</code> header of <code>application/x-www-form-urlencoded; charset=UTF-8</code>.  This condition was not imposed in prior versions of Firefox, but it appears 3.0 is quite strict in this regard.</p>

<p>Connection Manager users who send POST data with language-specific charsets will be impacted by this change in Firefox 3.0.</p>

<?php
include "../inc/support.inc";
?>

		</div>
         <div class="yui-u">

			<div id="cheatsheet">
				<h3>Connection Manager Cheat Sheet:</h3>

				<a href="http://yuiblog.com/assets/pdf/cheatsheets/connection.pdf"><img src="http://us.i1.yimg.com/us.yimg.com/i/ydn/yuiweb/img/cheatsheet-images/connection.gif" width="178" height="134" alt="Cheat Sheet for Connection Manager."></a>

				<p><a href="/yui/docs/assets/cheatsheets.zip">Download full set of cheat sheets.</a></p>
			</div>

			<div id="examples">
<?php
	include("../inc/examplesNav/".$section.".inc");
?>
		   </div>

			<div id="morereading">
				<h3>More Reading about the YUI Connection Manager:</h3>

				<ul>
				  <li><a href="http://yuiblog.com/assets/pdf/wellman-connectionmanager.pdf">Ajax and Connection Manager</a>, by Dan Wellman (PDF; 672KB); free excerpt from <em>Learning the Yahoo! User Interface Library</em>); this chapter includes two sample applications &mdash; a News Reader and a Login app</li>
				  <li><a href="http://www.developer.com/lang/print.php/10924_3600611_3">The Yahoo! Connection Manager</a>, by Nicholas Zakas (PDF; 716KB; free excerpt from <em>Professional Ajax</em>)</li>
				  <li><a href="http://www.developer.com/lang/print.php/10924_3600611_3">Ajax and the YUI Connection Manager</a>, by Nicholas Zakas</li>
				  <li><a href="http://www.hedgerwow.com/360/dhtml/yui-connection-watcher/demo.php">DHTML Widget: Connection Manager Watcher</a>, by Hedger Wang</li>
				  <li>From <a href="http://simon.incutio.com/slides/2006/xtech/yui-notes.html#connection">The Yahoo! User Interface Library</a>, by Simon Willison</li>
				  <li><a href="http://www.whenpenguinsattack.com/2006/12/12/how-to-create-a-php-upload-progress-meter/">How to Create a PHP Upload Meter (Using YUI)</a>, by Justin Silverton</li>
				  <li><a href="http://www.devchix.com/?s=connection+manager&Search.x=0&Search.y=0">Getting started with YUI's Connection Manager in Rails and PHP; or "All Happy Families Are Not Alike,"</a> by Desi McAdam</li>
			   </ul>
		   </div>

<?php
$thisURI="http://developer.yahoo.com/yui/connection/";
require_once('../inc/badge.inc');
?>
<h3 id="delicious">YUI Connection Manager on del.icio.us:</h3>
<div class="delicious">
<?php require('../inc/badge-html.inc'); ?>
</div>

		 </div>
      </div>

</div>
</div>

<?php include "../inc/side.inc" ?>
<?php include "../inc/footer.inc" ?>


